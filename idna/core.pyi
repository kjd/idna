from typing import Union
from .intranges import intranges_contain as intranges_contain  # noqa

class IDNAError(UnicodeError): ...
class IDNABidiError(IDNAError): ...
class InvalidCodepoint(IDNAError): ...
class InvalidCodepointContext(IDNAError): ...

def _combining_class(cp: int) -> int: ...
def _is_script(cp: str, script: str) -> bool: ...
def _punycode(s: str) -> bytes: ...
def _unot(s: int) -> str: ...
def valid_label_length(label: Union[str, bytes]) -> bool: ...
def valid_string_length(label: Union[str, bytes], trailing_dot: bool) -> bool: ...
def check_bidi(label: str, check_ltr: bool = ...) -> bool: ...
def check_initial_combiner(label: str) -> bool: ...
def check_hyphen_ok(label: str) -> bool: ...
def check_nfc(label: str) -> None: ...
def valid_contextj(label: str, pos: int) -> bool: ...
def valid_contexto(label: str, pos: int, exception: bool = False) -> bool: ...
def check_label(label: Union[str, bytes, bytearray]) -> None: ...
def alabel(label: str) -> bytes: ...
def ulabel(label: Union[str, bytes, bytearray]) -> str: ...
def uts46_remap(
    domain: str, std3_rules: bool = ..., transitional: bool = ...
) -> str: ...
def encode(
    s: Union[str, bytes, bytearray],
    strict: bool = False,
    uts46: bool = False,
    std3_rules: bool = False,
    transitional: bool = False,
) -> bytes: ...
def decode(
    s: Union[str, bytes, bytearray],
    strict: bool = ...,
    uts46: bool = ...,
    std3_rules: bool = ...,
) -> str: ...
